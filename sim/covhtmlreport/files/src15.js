var g_data = {"name":"C:/Users/arpit/OneDrive/Desktop/Project/I2C_VERIFICATION/sim/../rtl/i2c_master_top.v","src":"/////////////////////////////////////////////////////////////////////\n////                                                             ////\n////  WISHBONE revB.2 compliant I2C Master controller Top-level  ////\n////                                                             ////\n////                                                             ////\n////  Author: Richard Herveille                                  ////\n////          richard@asics.ws                                   ////\n////          www.asics.ws                                       ////\n////                                                             ////\n////  Downloaded from: http://www.opencores.org/projects/i2c/    ////\n////                                                             ////\n/////////////////////////////////////////////////////////////////////\n////                                                             ////\n//// Copyright (C) 2001 Richard Herveille                        ////\n////                    richard@asics.ws                         ////\n////                                                             ////\n//// This source file may be used and distributed without        ////\n//// restriction provided that this copyright statement is not   ////\n//// removed from the file and that any derivative work contains ////\n//// the original copyright notice and the associated disclaimer.////\n////                                                             ////\n////     THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY     ////\n//// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   ////\n//// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS   ////\n//// FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL THE AUTHOR      ////\n//// OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,         ////\n//// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES    ////\n//// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   ////\n//// GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        ////\n//// BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  ////\n//// LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT  ////\n//// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  ////\n//// OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE         ////\n//// POSSIBILITY OF SUCH DAMAGE.                                 ////\n////                                                             ////\n/////////////////////////////////////////////////////////////////////\n\n//  CVS Log\n//\n//  $Id: i2c_master_top.v,v 1.12 2009-01-19 20:29:26 rherveille Exp $\n//\n//  $Date: 2009-01-19 20:29:26 $\n//  $Revision: 1.12 $\n//  $Author: rherveille $\n//  $Locker:  $\n//  $State: Exp $\n//\n// Change History:\n//               Revision 1.11  2005/02/27 09:26:24  rherveille\n//               Fixed register overwrite issue.\n//               Removed full_case pragma, replaced it by a default statement.\n//\n//               Revision 1.10  2003/09/01 10:34:38  rherveille\n//               Fix a blocking vs. non-blocking error in the wb_dat output mux.\n//\n//               Revision 1.9  2003/01/09 16:44:45  rherveille\n//               Fixed a bug in the Command Register declaration.\n//\n//               Revision 1.8  2002/12/26 16:05:12  rherveille\n//               Small code simplifications\n//\n//               Revision 1.7  2002/12/26 15:02:32  rherveille\n//               Core is now a Multimaster I2C controller\n//\n//               Revision 1.6  2002/11/30 22:24:40  rherveille\n//               Cleaned up code\n//\n//               Revision 1.5  2001/11/10 10:52:55  rherveille\n//               Changed PRER reset value from 0x0000 to 0xffff, conform specs.\n//\n\n// synopsys translate_off\n`include \"timescale.v\"\n// synopsys translate_on\n\n`include \"i2c_master_defines.v\"\n`include \"i2c_master_byte_ctrl.v\"\n`include \"i2c_master_bit_ctrl.v\"\n\nmodule i2c_master_top(\n	wb_clk_i, wb_rst_i, arst_i, wb_adr_i, wb_dat_i, wb_dat_o,\n	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_inta_o,\n	scl_pad_i, scl_pad_o, scl_padoen_o, sda_pad_i, sda_pad_o, sda_padoen_o );\n\n	// parameters\n	parameter ARST_LVL = 1'b0; // asynchronous reset level\n\n	//\n	// inputs & outputs\n	//\n\n	// wishbone signals\n	input        wb_clk_i;     // master clock input\n	input        wb_rst_i;     // synchronous active high reset\n	input        arst_i;       // asynchronous reset\n	input  [2:0] wb_adr_i;     // lower address bits\n	input  [7:0] wb_dat_i;     // databus input\n	output [7:0] wb_dat_o;     // databus output\n	input        wb_we_i;      // write enable input\n	input        wb_stb_i;     // stobe/core select signal\n	input        wb_cyc_i;     // valid bus cycle input\n	output       wb_ack_o;     // bus cycle acknowledge output\n	output       wb_inta_o;    // interrupt request signal output\n\n	reg [7:0] wb_dat_o;\n	reg wb_ack_o;\n	reg wb_inta_o;\n\n	// I2C signals\n	// i2c clock line\n	input  scl_pad_i;       // SCL-line input\n	output scl_pad_o;       // SCL-line output (always 1'b0)\n	output scl_padoen_o;    // SCL-line output enable (active low)\n\n	// i2c data line\n	input  sda_pad_i;       // SDA-line input\n	output sda_pad_o;       // SDA-line output (always 1'b0)\n	output sda_padoen_o;    // SDA-line output enable (active low)\n\n\n	//\n	// variable declarations\n	//\n\n	// registers\n	reg  [15:0] prer; // clock prescale register\n	reg  [ 7:0] ctr;  // control register\n	reg  [ 7:0] txr;  // transmit register\n	wire [ 7:0] rxr;  // receive register\n	reg  [ 7:0] cr;   // command register\n	wire [ 7:0] sr;   // status register\n\n	// done signal: command completed, clear command register\n	wire done;\n\n	// core enable signal\n	wire core_en;\n	wire ien;\n\n	// status register signals\n	wire irxack;\n	reg  rxack;       // received aknowledge from slave\n	reg  tip;         // transfer in progress\n	reg  irq_flag;    // interrupt pending flag\n	wire i2c_busy;    // bus busy (start signal detected)\n	wire i2c_al;      // i2c bus arbitration lost\n	reg  al;          // status register arbitration lost bit\n\n	//\n	// module body\n	//\n\n	// generate internal reset\n	wire rst_i = arst_i ^ ARST_LVL;\n\n	// generate wishbone signals\n	wire wb_wacc = wb_we_i & wb_ack_o;\n\n	// generate acknowledge output signal\n	always @(posedge wb_clk_i)\n	  wb_ack_o <= #1 wb_cyc_i & wb_stb_i & ~wb_ack_o; // because timing is always honored\n\n	// assign DAT_O\n	always @(posedge wb_clk_i)\n	begin\n	  case (wb_adr_i) // synopsys parallel_case\n	    3'b000: wb_dat_o <= #1 prer[ 7:0];\n	    3'b001: wb_dat_o <= #1 prer[15:8];\n	    3'b010: wb_dat_o <= #1 ctr;\n	    3'b011: wb_dat_o <= #1 rxr; // write is transmit register (txr)\n	    3'b100: wb_dat_o <= #1 sr;  // write is command register (cr)\n	    3'b101: wb_dat_o <= #1 txr;\n	    3'b110: wb_dat_o <= #1 cr;\n	    3'b111: wb_dat_o <= #1 0;   // reserved\n	  endcase\n	end\n\n	// generate registers\n	always @(posedge wb_clk_i or negedge rst_i)\n	  if (!rst_i)\n	    begin\n	        prer <= #1 16'hffff;\n	        ctr  <= #1  8'h0;\n	        txr  <= #1  8'h0;\n	    end\n	  else if (wb_rst_i)\n	    begin\n	        prer <= #1 16'hffff;\n	        ctr  <= #1  8'h0;\n	        txr  <= #1  8'h0;\n	    end\n	  else\n	    if (wb_wacc)\n	      case (wb_adr_i) // synopsys parallel_case\n	         3'b000 : prer [ 7:0] <= #1 wb_dat_i;\n	         3'b001 : prer [15:8] <= #1 wb_dat_i;\n	         3'b010 : ctr         <= #1 wb_dat_i;\n	         3'b011 : txr         <= #1 wb_dat_i;\n	         default: ;\n	      endcase\n\n	// generate command register (special case)\n	always @(posedge wb_clk_i or negedge rst_i)\n	  if (!rst_i)\n	    cr <= #1 8'h0;\n	  else if (wb_rst_i)\n	    cr <= #1 8'h0;\n	  else if (wb_wacc)\n	    begin\n	        if (core_en & (wb_adr_i == 3'b100) )\n	          cr <= #1 wb_dat_i;\n	    end\n	  else\n	    begin\n	        if (done | i2c_al)\n	          cr[7:4] <= #1 4'h0;           // clear command bits when done\n	                                        // or when aribitration lost\n	        cr[2:1] <= #1 2'b0;             // reserved bits\n	        cr[0]   <= #1 1'b0;             // clear IRQ_ACK bit\n	    end\n\n\n	// decode command register\n	wire sta  = cr[7];\n	wire sto  = cr[6];\n	wire rd   = cr[5];\n	wire wr   = cr[4];\n	wire ack  = cr[3];\n	wire iack = cr[0];\n\n	// decode control register\n	assign core_en = ctr[7];\n	assign ien = ctr[6];\n\n	// hookup byte controller block\n	i2c_master_byte_ctrl byte_controller (\n		.clk      ( wb_clk_i     ),\n		.rst      ( wb_rst_i     ),\n		.nReset   ( rst_i        ),\n		.ena      ( core_en      ),\n		.clk_cnt  ( prer         ),\n		.start    ( sta          ),\n		.stop     ( sto          ),\n		.read     ( rd           ),\n		.write    ( wr           ),\n		.ack_in   ( ack          ),\n		.din      ( txr          ),\n		.cmd_ack  ( done         ),\n		.ack_out  ( irxack       ),\n		.dout     ( rxr          ),\n		.i2c_busy ( i2c_busy     ),\n		.i2c_al   ( i2c_al       ),\n		.scl_i    ( scl_pad_i    ),\n		.scl_o    ( scl_pad_o    ),\n		.scl_oen  ( scl_padoen_o ),\n		.sda_i    ( sda_pad_i    ),\n		.sda_o    ( sda_pad_o    ),\n		.sda_oen  ( sda_padoen_o )\n	);\n\n	// status register block + interrupt request signal\n	always @(posedge wb_clk_i or negedge rst_i)\n	  if (!rst_i)\n	    begin\n	        al       <= #1 1'b0;\n	        rxack    <= #1 1'b0;\n	        tip      <= #1 1'b0;\n	        irq_flag <= #1 1'b0;\n	    end\n	  else if (wb_rst_i)\n	    begin\n	        al       <= #1 1'b0;\n	        rxack    <= #1 1'b0;\n	        tip      <= #1 1'b0;\n	        irq_flag <= #1 1'b0;\n	    end\n	  else\n	    begin\n	        al       <= #1 i2c_al | (al & ~sta);\n	        rxack    <= #1 irxack;\n	        tip      <= #1 (rd | wr);\n	        irq_flag <= #1 (done | i2c_al | irq_flag) & ~iack; // interrupt request flag is always generated\n	    end\n\n	// generate interrupt request signals\n	always @(posedge wb_clk_i or negedge rst_i)\n	  if (!rst_i)\n	    wb_inta_o <= #1 1'b0;\n	  else if (wb_rst_i)\n	    wb_inta_o <= #1 1'b0;\n	  else\n	    wb_inta_o <= #1 irq_flag && ien; // interrupt signal is only generated when IEN (interrupt enable bit is set)\n\n	// assign status register bits\n	assign sr[7]   = rxack;\n	assign sr[6]   = i2c_busy;\n	assign sr[5]   = al;\n	assign sr[4:2] = 3'h0; // reserved\n	assign sr[1]   = tip;\n	assign sr[0]   = irq_flag;\n\nendmodule\n","lang":"verilog"};
processSrcData(g_data);