var g_data = {"name":"C:/Users/arpit/OneDrive/Desktop/Project/I2C_VERIFICATION/sim/../master/wb_seq.sv","src":"class base_seq_lib extends uvm_sequence#(wb_tx);\n	`uvm_object_utils(base_seq_lib)\n	`NEW_OBJ\n\n	task pre_body();\n		starting_phase = get_starting_phase();\n		if(starting_phase != null)\n			starting_phase.raise_objection(this);\n	endtask\n\n	task post_body();\n		if(starting_phase != null)\n			starting_phase.phase_done.set_drain_time(this,2000);\n			starting_phase.drop_objection(this);\n	endtask\n\n	task wait_for_tip();\n		do begin\n			`uvm_do_with(req, {req.wr_rd==0; req.addr==`SR;});\n			get_response(rsp);\n		end while (rsp.data[1] == 1'b1); // Wait for TIP to clear\n	endtask\nendclass\n\nclass config_clock_seq extends base_seq_lib;\n	`uvm_object_utils(config_clock_seq)\n	`NEW_OBJ\n\n	task body();\n	//initialize core\n		//clk = 50 MHz\n		//SCL = 40KHz \n		//PRER = (WB_CLK /(5*SCL))-1 =\n		//PRE = 249 = F9(hex)\n		//disable core\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`CTR; req.data==8'h00;});\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`PRERLo; req.data==8'hF9;});\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`PRERHi; req.data==8'h00;});\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`CTR; req.data==8'hC0;});\n	endtask\nendclass\n\nclass config_clock_400KHZ_seq extends base_seq_lib;\n	`uvm_object_utils(config_clock_400KHZ_seq)\n	`NEW_OBJ\n\n	task body();\n	//initialize core\n		//clk = 50 MHz\n		//SCL = 100KHz \n		//PRER = (WB_CLK /(5*SCL))-1 =\n		//PRE = 24 = 18(hex)\n		//disable core\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`CTR; req.data==8'h00;});\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`PRERLo; req.data==8'h18;});\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`PRERHi; req.data==8'h00;});\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`CTR; req.data==8'hC0;});\n	endtask\nendclass\n\nclass config_clock_300HZ_seq extends base_seq_lib;\n	`uvm_object_utils(config_clock_300HZ_seq)\n	`NEW_OBJ\n\n	task body();\n	//initialize core\n		//clk = 50 MHz\n		//SCL = 300Hz \n		//PRER = (WB_CLK /(5*SCL))-1 =\n		//PRE = 33332 = 8234(hex)\n		//disable core\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`CTR; req.data==8'h00;});\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`PRERLo; req.data==8'h34;});\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`PRERHi; req.data==8'h82;});\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`CTR; req.data==8'hC0;});\n	endtask\nendclass\n\nclass write_seq extends base_seq_lib;\n	`uvm_object_utils(write_seq)\n	`NEW_OBJ\n	config_clock_seq clock_seq;\n\n	task body();\n		`uvm_do(clock_seq)\n\n		//------------------------------------------------------\n		//WRITE ADDRESS TO SLAVE\n		//------------------------------------------------------\n		//load slave address + W bit\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`TXR; req.data=={7'h10,1'b0};});\n		//start + write\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`CR; req.data==8'h90;});\n\n		wait_for_tip();\n\n		//read RxACK bit\n		if(rsp.data[7]==1'b1) begin\n			`uvm_error(\"STATUS_ERR\", \"Slave NaCK the address\")\n			return;\n		end\n		else `uvm_info(\"SR\",\"slave ack the address\", UVM_LOW)\n\n		//------------------------------------------------------\n		//SET MEMORY ADDRESS POINTER\n		//------------------------------------------------------\n		//valid memory pointer from 0-15\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`TXR; req.data==8'h01;});\n		//write only\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`CR; req.data==8'h10;});\n		wait_for_tip();\n	\n		//------------------------------------------------------\n		//LOAD DATA\n		//------------------------------------------------------\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`TXR; req.data==8'hA5;});\n		//set STO + WR\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`CR; req.data==8'h50;});\n\n		wait_for_tip();\n\n		//read RxACK bit\n		if(rsp.data[7]==1'b1) begin\n			`uvm_error(\"STATUS_ERR\", \"Slave NaCK the data\")\n			return;\n		end\n		else `uvm_info(\"SR\",\"slave ack the data\", UVM_LOW)\n	endtask\nendclass\n\nclass write_read_seq extends base_seq_lib;\n	`uvm_object_utils(write_read_seq)\n	`NEW_OBJ\n	write_seq		 write_seq_inst;\n\n	task body();\n		`uvm_do(write_seq_inst)\n		\n		//RESET ADDRESS POINTER TO 0X05\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`TXR; req.data=={7'h10,1'b0};});\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`CR; req.data==8'h90;});\n		wait_for_tip();\n\n		//Memory address (0x05) - this resets the pointer\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`TXR; req.data==8'h01;});\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`CR; req.data==8'h10;});\n		wait_for_tip();\n\n\n		//-------------------------------------------------\n		//read phase\n		//-------------------------------------------------\n		//write slave address + read bit\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`TXR; req.data=={7'h10,1'b1};});\n		//repeated start + write\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`CR; req.data==8'h90;});\n\n		wait_for_tip();\n\n		//STO + RD + NACK\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`CR; req.data==8'h68;});\n\n		wait_for_tip();\n\n		//read byte from slave\n		`uvm_do_with(req, {req.wr_rd==0; req.addr==`RXR;});\n		get_response(rsp);\n\n		if(rsp.data==8'hA5)\n			`uvm_info(\"RD_DATA\", \"Read back 0xA5\", UVM_LOW)\n		else\n			`uvm_error(\"RD_ERR\", $sformatf(\"Mismatch! Expected 0xA5, got 0x%0h\",rsp.data))\n	endtask\nendclass\n\nclass nack_seq extends base_seq_lib;\n	`uvm_object_utils(nack_seq)\n	`NEW_OBJ\n\n	config_clock_seq clock_seq;\n\n	task body();\n		`uvm_do(clock_seq)\n        \n        //Slave Address + Write\n        `uvm_do_with(req, {req.wr_rd==1; req.addr==`TXR; req.data=={7'h70,1'b0};});\n        `uvm_do_with(req, {req.wr_rd==1; req.addr==`CR; req.data==8'h90;}); \n        wait_for_tip();\n\n        //Invalid Memory Address 0x05\n        `uvm_do_with(req, {req.wr_rd==1; req.addr==`TXR; req.data==8'h05;});\n        `uvm_do_with(req, {req.wr_rd==1; req.addr==`CR; req.data==8'h10;}); \n        wait_for_tip();\n\n        //CHECK FOR NACK (Bit 7 of SR)\n        if(rsp.data[7] == 1'b1) \n            `uvm_info(\"NACK_RXD\", \"SUCCESS: Correctly received NACK for invalid address\", UVM_LOW)\n        else\n            `uvm_error(\"NACK_ERR\", \"FAILURE: Master received ACK for invalid address 0x05!\")\n\n        //STOP\n        `uvm_do_with(req, {req.wr_rd==1; req.addr==`CR; req.data==8'h50;}); \n		//ack interrupt\n        `uvm_do_with(req, {req.wr_rd==1; req.addr==`CR; req.data==8'h01;}); \n        wait_for_tip();\n	endtask\nendclass\n\n\nclass burst_write_read_seq extends base_seq_lib;\n	`uvm_object_utils(burst_write_read_seq)\n	`NEW_OBJ\n	int burst_len = 4;\n\n	config_clock_400KHZ_seq clock_400_seq;\n	task body();\n		`uvm_do(clock_400_seq)\n		\n		//------------------------------------------------------\n		//WRITE ADDRESS TO SLAVE\n		//------------------------------------------------------\n		//load slave address + W bit\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`TXR; req.data=={7'h10,1'b0};});\n		//start + write\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`CR; req.data==8'h90;});\n\n		wait_for_tip();\n\n		//------------------------------------------------------\n		//SET MEMORY ADDRESS POINTER\n		//------------------------------------------------------\n		//valid memory pointer from 0-15\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`TXR; req.data==8'h00;});\n		//write only\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`CR; req.data==8'h10;});\n		wait_for_tip();\n	\n		//------------------------------------------------------\n		//LOAD DATA\n		//------------------------------------------------------\n		for (int i=0; i<burst_len; i++) begin\n			`uvm_do_with(req, {req.wr_rd==1; req.addr==`TXR; req.data==8'hA5+i;});\n			if (i == burst_len -1) begin \n				//send stop\n				`uvm_do_with(req, {req.wr_rd==1; req.addr==`CR; req.data==8'h50;});\n			end else \n				`uvm_do_with(req, {req.wr_rd==1; req.addr==`CR; req.data==8'h10;});\n			wait_for_tip();\n		end\n		\n		//RESET ADDRESS POINTER TO 0X00\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`TXR; req.data=={7'h10,1'b0};});\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`CR; req.data==8'h90;});\n		wait_for_tip();\n\n		//Memory address (0x00) - this resets the pointer\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`TXR; req.data==8'h00;});\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`CR; req.data==8'h10;});\n		wait_for_tip();\n\n		//-------------------------------------------------\n		//read phase\n		//-------------------------------------------------\n		//write slave address + read bit\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`TXR; req.data=={7'h10,1'b1};});\n		//repeated start + write\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`CR; req.data==8'h90;});\n\n		wait_for_tip();\n\n		//read byte from slave\n		for (int i=0; i<burst_len; i++) begin\n			if (i == burst_len -1) begin\n				//STO + RD + NACK\n				`uvm_do_with(req, {req.wr_rd==1; req.addr==`CR; req.data==8'h68;});\n			end else\n				//read + ack\n				`uvm_do_with(req, {req.wr_rd==1; req.addr==`CR; req.data==8'h20;});\n			wait_for_tip();\n			\n			//fetch data\n			`uvm_do_with(req, {req.wr_rd==0; req.addr==`RXR;});\n			get_response(rsp);\n\n			if(rsp.data==8'hA5+i)\n				`uvm_info(\"RD_DATA\", $sformatf(\"Index %0d: Read 0x%0h Match\",i,rsp.data), UVM_LOW)\n			else\n				`uvm_error(\"RD_DATA_ERR\", $sformatf(\"Index %0d: Expected 0x%0h got 0x%0h\",i,(8'hA5+i),rsp.data))\n		end\n	endtask\nendclass\n\nclass write_low_freq_seq extends base_seq_lib;\n	`uvm_object_utils(write_low_freq_seq)\n	`NEW_OBJ\n	config_clock_300HZ_seq clock_300_seq;\n	task body();\n		`uvm_do(clock_300_seq)\n\n		//------------------------------------------------------\n		//WRITE ADDRESS TO SLAVE\n		//------------------------------------------------------\n		//load slave address + W bit\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`TXR; req.data=={7'h10,1'b0};});\n		//start + write\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`CR; req.data==8'h90;});\n\n		wait_for_tip();\n\n		//read RxACK bit\n		if(rsp.data[7]==1'b1) begin\n			`uvm_error(\"STATUS_ERR\", \"Slave NaCK the address\")\n			return;\n		end\n		else `uvm_info(\"SR\",\"slave ack the address\", UVM_LOW)\n\n		//------------------------------------------------------\n		//SET MEMORY ADDRESS POINTER\n		//------------------------------------------------------\n		//valid memory pointer from 0-15\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`TXR; req.data==8'h01;});\n		//write only\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`CR; req.data==8'h10;});\n		wait_for_tip();\n	\n		//------------------------------------------------------\n		//LOAD DATA\n		//------------------------------------------------------\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`TXR; req.data==8'hA5;});\n		//set STO + WR\n		`uvm_do_with(req, {req.wr_rd==1; req.addr==`CR; req.data==8'h50;});\n\n		wait_for_tip();\n\n		//read RxACK bit\n		if(rsp.data[7]==1'b1) begin\n			`uvm_error(\"STATUS_ERR\", \"Slave NaCK the data\")\n			return;\n		end\n		else `uvm_info(\"SR\",\"slave ack the data\", UVM_LOW)\n	endtask\nendclass\n\nclass reset_during_xfer_seq extends base_seq_lib;\n	`uvm_object_utils(reset_during_xfer_seq)\n	`NEW_OBJ\n	config_clock_400KHZ_seq clock_seq;\n\n	task body();\n		`uvm_do(clock_seq)\n\n        `uvm_do_with(req, {req.wr_rd==1; req.addr==`TXR; req.data==8'hAA;});\n        `uvm_do_with(req, {req.wr_rd==1; req.addr==`CR;  req.data==8'h90;}); // START + WR\n\n		wait_for_tip();\n\n        //TRIGGER THE RESET\n        fork\n            begin\n                #10; \n                force top.rst_n= 1'b1; \n                #500ns;\n                release top.rst_n;\n                force top.rst_n = 1'b0;\n            end\n        join_none\n\n        //Core should have dropped everything\n        #1;\n        `uvm_do_with(req, {req.wr_rd==0; req.addr==`SR;});\n        get_response(rsp);\n\n        // After reset, TIP should be 0 and the FSM should be in IDLE\n        if(rsp.data[1] == 1'b0) begin\n            `uvm_info(\"RST\", \"SUCCESS: Master returned to IDLE after reset.\", UVM_LOW)\n        end else begin\n            `uvm_error(\"RST\", \"FAILURE: Master still shows TIP=1 after reset!\")\n        end\n	endtask\nendclass\n","lang":"verilog"};
processSrcData(g_data);