var g_data = {"name":"C:/Users/arpit/OneDrive/Desktop/Project/I2C_VERIFICATION/sim/../rtl/i2c_master_bit_ctrl.v","src":"/////////////////////////////////////////////////////////////////////\n////                                                             ////\n////  WISHBONE rev.B2 compliant I2C Master bit-controller        ////\n////                                                             ////\n////                                                             ////\n////  Author: Richard Herveille                                  ////\n////          richard@asics.ws                                   ////\n////          www.asics.ws                                       ////\n////                                                             ////\n////  Downloaded from: http://www.opencores.org/projects/i2c/    ////\n////                                                             ////\n/////////////////////////////////////////////////////////////////////\n////                                                             ////\n//// Copyright (C) 2001 Richard Herveille                        ////\n////                    richard@asics.ws                         ////\n////                                                             ////\n//// This source file may be used and distributed without        ////\n//// restriction provided that this copyright statement is not   ////\n//// removed from the file and that any derivative work contains ////\n//// the original copyright notice and the associated disclaimer.////\n////                                                             ////\n////     THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY     ////\n//// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   ////\n//// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS   ////\n//// FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL THE AUTHOR      ////\n//// OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,         ////\n//// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES    ////\n//// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   ////\n//// GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        ////\n//// BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  ////\n//// LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT  ////\n//// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  ////\n//// OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE         ////\n//// POSSIBILITY OF SUCH DAMAGE.                                 ////\n////                                                             ////\n/////////////////////////////////////////////////////////////////////\n\n//  CVS Log\n//\n//  $Id: i2c_master_bit_ctrl.v,v 1.14 2009-01-20 10:25:29 rherveille Exp $\n//\n//  $Date: 2009-01-20 10:25:29 $\n//  $Revision: 1.14 $\n//  $Author: rherveille $\n//  $Locker:  $\n//  $State: Exp $\n//\n// Change History:\n//               $Log: $\n//               Revision 1.14  2009/01/20 10:25:29  rherveille\n//               Added clock synchronization logic\n//               Fixed slave_wait signal\n//\n//               Revision 1.13  2009/01/19 20:29:26  rherveille\n//               Fixed synopsys miss spell (synopsis)\n//               Fixed cr[0] register width\n//               Fixed ! usage instead of ~\n//               Fixed bit controller parameter width to 18bits\n//\n//               Revision 1.12  2006/09/04 09:08:13  rherveille\n//               fixed short scl high pulse after clock stretch\n//               fixed slave model not returning correct '(n)ack' signal\n//\n//               Revision 1.11  2004/05/07 11:02:26  rherveille\n//               Fixed a bug where the core would signal an arbitration lost (AL bit set), when another master controls the bus and the other master generates a STOP bit.\n//\n//               Revision 1.10  2003/08/09 07:01:33  rherveille\n//               Fixed a bug in the Arbitration Lost generation caused by delay on the (external) sda line.\n//               Fixed a potential bug in the byte controller's host-acknowledge generation.\n//\n//               Revision 1.9  2003/03/10 14:26:37  rherveille\n//               Fixed cmd_ack generation item (no bug).\n//\n//               Revision 1.8  2003/02/05 00:06:10  rherveille\n//               Fixed a bug where the core would trigger an erroneous 'arbitration lost' interrupt after being reset, when the reset pulse width < 3 clk cycles.\n//\n//               Revision 1.7  2002/12/26 16:05:12  rherveille\n//               Small code simplifications\n//\n//               Revision 1.6  2002/12/26 15:02:32  rherveille\n//               Core is now a Multimaster I2C controller\n//\n//               Revision 1.5  2002/11/30 22:24:40  rherveille\n//               Cleaned up code\n//\n//               Revision 1.4  2002/10/30 18:10:07  rherveille\n//               Fixed some reported minor start/stop generation timing issuess.\n//\n//               Revision 1.3  2002/06/15 07:37:03  rherveille\n//               Fixed a small timing bug in the bit controller.\\nAdded verilog simulation environment.\n//\n//               Revision 1.2  2001/11/05 11:59:25  rherveille\n//               Fixed wb_ack_o generation bug.\n//               Fixed bug in the byte_controller statemachine.\n//               Added headers.\n//\n\n//\n/////////////////////////////////////\n// Bit controller section\n/////////////////////////////////////\n//\n// Translate simple commands into SCL/SDA transitions\n// Each command has 5 states, A/B/C/D/idle\n//\n// start:	SCL	~~~~~~~~~~\\____\n//	SDA	~~~~~~~~\\______\n//		 x | A | B | C | D | i\n//\n// repstart	SCL	____/~~~~\\___\n//	SDA	__/~~~\\______\n//		 x | A | B | C | D | i\n//\n// stop	SCL	____/~~~~~~~~\n//	SDA	==\\____/~~~~~\n//		 x | A | B | C | D | i\n//\n//- write	SCL	____/~~~~\\____\n//	SDA	==X=========X=\n//		 x | A | B | C | D | i\n//\n//- read	SCL	____/~~~~\\____\n//	SDA	XXXX=====XXXX\n//		 x | A | B | C | D | i\n//\n\n// Timing:     Normal mode      Fast mode\n///////////////////////////////////////////////////////////////////////\n// Fscl        100KHz           400KHz\n// Th_scl      4.0us            0.6us   High period of SCL\n// Tl_scl      4.7us            1.3us   Low period of SCL\n// Tsu:sta     4.7us            0.6us   setup time for a repeated start condition\n// Tsu:sto     4.0us            0.6us   setup time for a stop conditon\n// Tbuf        4.7us            1.3us   Bus free time between a stop and start condition\n//\n\n// synopsys translate_off\n`include \"timescale.v\"\n// synopsys translate_on\n\n`include \"i2c_master_defines.v\"\n\nmodule i2c_master_bit_ctrl (\n    input             clk,      // system clock\n    input             rst,      // synchronous active high reset\n    input             nReset,   // asynchronous active low reset\n    input             ena,      // core enable signal\n\n    input      [15:0] clk_cnt,  // clock prescale value\n\n    input      [ 3:0] cmd,      // command (from byte controller)\n    output reg        cmd_ack,  // command complete acknowledge\n    output reg        busy,     // i2c bus busy\n    output reg        al,       // i2c bus arbitration lost\n\n    input             din,\n    output reg        dout,\n\n    input             scl_i,    // i2c clock line input\n    output            scl_o,    // i2c clock line output\n    output reg        scl_oen,  // i2c clock line output enable (active low)\n    input             sda_i,    // i2c data line input\n    output            sda_o,    // i2c data line output\n    output reg        sda_oen   // i2c data line output enable (active low)\n);\n\n\n    //\n    // variable declarations\n    //\n\n    reg [ 1:0] cSCL, cSDA;      // capture SCL and SDA\n    reg [ 2:0] fSCL, fSDA;      // SCL and SDA filter inputs\n    reg        sSCL, sSDA;      // filtered and synchronized SCL and SDA inputs\n    reg        dSCL, dSDA;      // delayed versions of sSCL and sSDA\n    reg        dscl_oen;        // delayed scl_oen\n    reg        sda_chk;         // check SDA output (Multi-master arbitration)\n    reg        clk_en;          // clock generation signals\n    reg        slave_wait;      // slave inserts wait states\n    reg [15:0] cnt;             // clock divider counter (synthesis)\n    reg [13:0] filter_cnt;      // clock divider for filter\n\n\n    // state machine variable\n    reg [17:0] c_state; // synopsys enum_state\n\n    //\n    // module body\n    //\n\n    // whenever the slave is not ready it can delay the cycle by pulling SCL low\n    // delay scl_oen\n    always @(posedge clk)\n      dscl_oen <= #1 scl_oen;\n\n    // slave_wait is asserted when master wants to drive SCL high, but the slave pulls it low\n    // slave_wait remains asserted until the slave releases SCL\n    always @(posedge clk or negedge nReset)\n      if (!nReset) slave_wait <= 1'b0;\n      else         slave_wait <= (scl_oen & ~dscl_oen & ~sSCL) | (slave_wait & ~sSCL);\n\n    // master drives SCL high, but another master pulls it low\n    // master start counting down its low cycle now (clock synchronization)\n    wire scl_sync   = dSCL & ~sSCL & scl_oen;\n\n\n    // generate clk enable signal\n    always @(posedge clk or negedge nReset)\n      if (~nReset)\n      begin\n          cnt    <= #1 16'h0;\n          clk_en <= #1 1'b1;\n      end\n      else if (rst || ~|cnt || !ena || scl_sync)\n      begin\n          cnt    <= #1 clk_cnt;\n          clk_en <= #1 1'b1;\n      end\n      else if (slave_wait)\n      begin\n          cnt    <= #1 cnt;\n          clk_en <= #1 1'b0;    \n      end\n      else\n      begin\n          cnt    <= #1 cnt - 16'h1;\n          clk_en <= #1 1'b0;\n      end\n\n\n    // generate bus status controller\n\n    // capture SDA and SCL\n    // reduce metastability risk\n    always @(posedge clk or negedge nReset)\n      if (!nReset)\n      begin\n          cSCL <= #1 2'b00;\n          cSDA <= #1 2'b00;\n      end\n      else if (rst)\n      begin\n          cSCL <= #1 2'b00;\n          cSDA <= #1 2'b00;\n      end\n      else\n      begin\n          cSCL <= {cSCL[0],scl_i};\n          cSDA <= {cSDA[0],sda_i};\n      end\n\n\n    // filter SCL and SDA signals; (attempt to) remove glitches\n    always @(posedge clk or negedge nReset)\n      if      (!nReset     ) filter_cnt <= 14'h0;\n      else if (rst || !ena ) filter_cnt <= 14'h0;\n      else if (~|filter_cnt) filter_cnt <= clk_cnt >> 2; //16x I2C bus frequency\n      else                   filter_cnt <= filter_cnt -1;\n\n\n    always @(posedge clk or negedge nReset)\n      if (!nReset)\n      begin\n          fSCL <= 3'b111;\n          fSDA <= 3'b111;\n      end\n      else if (rst)\n      begin\n          fSCL <= 3'b111;\n          fSDA <= 3'b111;\n      end\n      else if (~|filter_cnt)\n      begin\n          fSCL <= {fSCL[1:0],cSCL[1]};\n          fSDA <= {fSDA[1:0],cSDA[1]};\n      end\n\n\n    // generate filtered SCL and SDA signals\n    always @(posedge clk or negedge nReset)\n      if (~nReset)\n      begin\n          sSCL <= #1 1'b1;\n          sSDA <= #1 1'b1;\n\n          dSCL <= #1 1'b1;\n          dSDA <= #1 1'b1;\n      end\n      else if (rst)\n      begin\n          sSCL <= #1 1'b1;\n          sSDA <= #1 1'b1;\n\n          dSCL <= #1 1'b1;\n          dSDA <= #1 1'b1;\n      end\n      else\n      begin\n          sSCL <= #1 &fSCL[2:1] | &fSCL[1:0] | (fSCL[2] & fSCL[0]);\n          sSDA <= #1 &fSDA[2:1] | &fSDA[1:0] | (fSDA[2] & fSDA[0]);\n\n          dSCL <= #1 sSCL;\n          dSDA <= #1 sSDA;\n      end\n\n    // detect start condition => detect falling edge on SDA while SCL is high\n    // detect stop condition => detect rising edge on SDA while SCL is high\n    reg sta_condition;\n    reg sto_condition;\n    always @(posedge clk or negedge nReset)\n      if (~nReset)\n      begin\n          sta_condition <= #1 1'b0;\n          sto_condition <= #1 1'b0;\n      end\n      else if (rst)\n      begin\n          sta_condition <= #1 1'b0;\n          sto_condition <= #1 1'b0;\n      end\n      else\n      begin\n          sta_condition <= #1 ~sSDA &  dSDA & sSCL;\n          sto_condition <= #1  sSDA & ~dSDA & sSCL;\n      end\n\n\n    // generate i2c bus busy signal\n    always @(posedge clk or negedge nReset)\n      if      (!nReset) busy <= #1 1'b0;\n      else if (rst    ) busy <= #1 1'b0;\n      else              busy <= #1 (sta_condition | busy) & ~sto_condition;\n\n\n    // generate arbitration lost signal\n    // aribitration lost when:\n    // 1) master drives SDA high, but the i2c bus is low\n    // 2) stop detected while not requested\n    reg cmd_stop;\n    always @(posedge clk or negedge nReset)\n      if (~nReset)\n          cmd_stop <= #1 1'b0;\n      else if (rst)\n          cmd_stop <= #1 1'b0;\n      else if (clk_en)\n          cmd_stop <= #1 cmd == `I2C_CMD_STOP;\n\n    always @(posedge clk or negedge nReset)\n      if (~nReset)\n          al <= #1 1'b0;\n      else if (rst)\n          al <= #1 1'b0;\n      else\n          al <= #1 (sda_chk & ~sSDA & sda_oen) | (|c_state & sto_condition & ~cmd_stop);\n\n\n    // generate dout signal (store SDA on rising edge of SCL)\n    always @(posedge clk)\n      if (sSCL & ~dSCL) dout <= #1 sSDA;\n\n\n    // generate statemachine\n\n    // nxt_state decoder\n    parameter [17:0] idle    = 18'b0_0000_0000_0000_0000;\n    parameter [17:0] start_a = 18'b0_0000_0000_0000_0001;\n    parameter [17:0] start_b = 18'b0_0000_0000_0000_0010;\n    parameter [17:0] start_c = 18'b0_0000_0000_0000_0100;\n    parameter [17:0] start_d = 18'b0_0000_0000_0000_1000;\n    parameter [17:0] start_e = 18'b0_0000_0000_0001_0000;\n    parameter [17:0] stop_a  = 18'b0_0000_0000_0010_0000;\n    parameter [17:0] stop_b  = 18'b0_0000_0000_0100_0000;\n    parameter [17:0] stop_c  = 18'b0_0000_0000_1000_0000;\n    parameter [17:0] stop_d  = 18'b0_0000_0001_0000_0000;\n    parameter [17:0] rd_a    = 18'b0_0000_0010_0000_0000;\n    parameter [17:0] rd_b    = 18'b0_0000_0100_0000_0000;\n    parameter [17:0] rd_c    = 18'b0_0000_1000_0000_0000;\n    parameter [17:0] rd_d    = 18'b0_0001_0000_0000_0000;\n    parameter [17:0] wr_a    = 18'b0_0010_0000_0000_0000;\n    parameter [17:0] wr_b    = 18'b0_0100_0000_0000_0000;\n    parameter [17:0] wr_c    = 18'b0_1000_0000_0000_0000;\n    parameter [17:0] wr_d    = 18'b1_0000_0000_0000_0000;\n\n    always @(posedge clk or negedge nReset)\n      if (!nReset)\n      begin\n          c_state <= #1 idle;\n          cmd_ack <= #1 1'b0;\n          scl_oen <= #1 1'b1;\n          sda_oen <= #1 1'b1;\n          sda_chk <= #1 1'b0;\n      end\n      else if (rst | al)\n      begin\n          c_state <= #1 idle;\n          cmd_ack <= #1 1'b0;\n          scl_oen <= #1 1'b1;\n          sda_oen <= #1 1'b1;\n          sda_chk <= #1 1'b0;\n      end\n      else\n      begin\n          cmd_ack   <= #1 1'b0; // default no command acknowledge + assert cmd_ack only 1clk cycle\n\n          if (clk_en)\n              case (c_state) // synopsys full_case parallel_case\n                    // idle state\n                    idle:\n                    begin\n                        case (cmd) // synopsys full_case parallel_case\n                             `I2C_CMD_START: c_state <= #1 start_a;\n                             `I2C_CMD_STOP:  c_state <= #1 stop_a;\n                             `I2C_CMD_WRITE: c_state <= #1 wr_a;\n                             `I2C_CMD_READ:  c_state <= #1 rd_a;\n                             default:        c_state <= #1 idle;\n                        endcase\n\n                        scl_oen <= #1 scl_oen; // keep SCL in same state\n                        sda_oen <= #1 sda_oen; // keep SDA in same state\n                        sda_chk <= #1 1'b0;    // don't check SDA output\n                    end\n\n                    // start\n                    start_a:\n                    begin\n                        c_state <= #1 start_b;\n                        scl_oen <= #1 scl_oen; // keep SCL in same state\n                        sda_oen <= #1 1'b1;    // set SDA high\n                        sda_chk <= #1 1'b0;    // don't check SDA output\n                    end\n\n                    start_b:\n                    begin\n                        c_state <= #1 start_c;\n                        scl_oen <= #1 1'b1; // set SCL high\n                        sda_oen <= #1 1'b1; // keep SDA high\n                        sda_chk <= #1 1'b0; // don't check SDA output\n                    end\n\n                    start_c:\n                    begin\n                        c_state <= #1 start_d;\n                        scl_oen <= #1 1'b1; // keep SCL high\n                        sda_oen <= #1 1'b0; // set SDA low\n                        sda_chk <= #1 1'b0; // don't check SDA output\n                    end\n\n                    start_d:\n                    begin\n                        c_state <= #1 start_e;\n                        scl_oen <= #1 1'b1; // keep SCL high\n                        sda_oen <= #1 1'b0; // keep SDA low\n                        sda_chk <= #1 1'b0; // don't check SDA output\n                    end\n\n                    start_e:\n                    begin\n                        c_state <= #1 idle;\n                        cmd_ack <= #1 1'b1;\n                        scl_oen <= #1 1'b0; // set SCL low\n                        sda_oen <= #1 1'b0; // keep SDA low\n                        sda_chk <= #1 1'b0; // don't check SDA output\n                    end\n\n                    // stop\n                    stop_a:\n                    begin\n                        c_state <= #1 stop_b;\n                        scl_oen <= #1 1'b0; // keep SCL low\n                        sda_oen <= #1 1'b0; // set SDA low\n                        sda_chk <= #1 1'b0; // don't check SDA output\n                    end\n\n                    stop_b:\n                    begin\n                        c_state <= #1 stop_c;\n                        scl_oen <= #1 1'b1; // set SCL high\n                        sda_oen <= #1 1'b0; // keep SDA low\n                        sda_chk <= #1 1'b0; // don't check SDA output\n                    end\n\n                    stop_c:\n                    begin\n                        c_state <= #1 stop_d;\n                        scl_oen <= #1 1'b1; // keep SCL high\n                        sda_oen <= #1 1'b0; // keep SDA low\n                        sda_chk <= #1 1'b0; // don't check SDA output\n                    end\n\n                    stop_d:\n                    begin\n                        c_state <= #1 idle;\n                        cmd_ack <= #1 1'b1;\n                        scl_oen <= #1 1'b1; // keep SCL high\n                        sda_oen <= #1 1'b1; // set SDA high\n                        sda_chk <= #1 1'b0; // don't check SDA output\n                    end\n\n                    // read\n                    rd_a:\n                    begin\n                        c_state <= #1 rd_b;\n                        scl_oen <= #1 1'b0; // keep SCL low\n                        sda_oen <= #1 1'b1; // tri-state SDA\n                        sda_chk <= #1 1'b0; // don't check SDA output\n                    end\n\n                    rd_b:\n                    begin\n                        c_state <= #1 rd_c;\n                        scl_oen <= #1 1'b1; // set SCL high\n                        sda_oen <= #1 1'b1; // keep SDA tri-stated\n                        sda_chk <= #1 1'b0; // don't check SDA output\n                    end\n\n                    rd_c:\n                    begin\n                        c_state <= #1 rd_d;\n                        scl_oen <= #1 1'b1; // keep SCL high\n                        sda_oen <= #1 1'b1; // keep SDA tri-stated\n                        sda_chk <= #1 1'b0; // don't check SDA output\n                    end\n\n                    rd_d:\n                    begin\n                        c_state <= #1 idle;\n                        cmd_ack <= #1 1'b1;\n                        scl_oen <= #1 1'b0; // set SCL low\n                        sda_oen <= #1 1'b1; // keep SDA tri-stated\n                        sda_chk <= #1 1'b0; // don't check SDA output\n                    end\n\n                    // write\n                    wr_a:\n                    begin\n                        c_state <= #1 wr_b;\n                        scl_oen <= #1 1'b0; // keep SCL low\n                        sda_oen <= #1 din;  // set SDA\n                        sda_chk <= #1 1'b0; // don't check SDA output (SCL low)\n                    end\n\n                    wr_b:\n                    begin\n                        c_state <= #1 wr_c;\n                        scl_oen <= #1 1'b1; // set SCL high\n                        sda_oen <= #1 din;  // keep SDA\n                        sda_chk <= #1 1'b0; // don't check SDA output yet\n                                            // allow some time for SDA and SCL to settle\n                    end\n\n                    wr_c:\n                    begin\n                        c_state <= #1 wr_d;\n                        scl_oen <= #1 1'b1; // keep SCL high\n                        sda_oen <= #1 din;\n                        sda_chk <= #1 1'b1; // check SDA output\n                    end\n\n                    wr_d:\n                    begin\n                        c_state <= #1 idle;\n                        cmd_ack <= #1 1'b1;\n                        scl_oen <= #1 1'b0; // set SCL low\n                        sda_oen <= #1 din;\n                        sda_chk <= #1 1'b0; // don't check SDA output (SCL low)\n                    end\n\n              endcase\n      end\n\n\n    // assign scl and sda output (always gnd)\n    assign scl_o = 1'b0;\n    assign sda_o = 1'b0;\n\nendmodule\n","lang":"verilog"};
processSrcData(g_data);