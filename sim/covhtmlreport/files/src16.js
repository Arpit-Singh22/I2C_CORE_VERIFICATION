var g_data = {"name":"C:/Users/arpit/OneDrive/Desktop/Project/I2C_VERIFICATION/sim/../rtl/i2c_master_byte_ctrl.v","src":"/////////////////////////////////////////////////////////////////////\n////                                                             ////\n////  WISHBONE rev.B2 compliant I2C Master byte-controller       ////\n////                                                             ////\n////                                                             ////\n////  Author: Richard Herveille                                  ////\n////          richard@asics.ws                                   ////\n////          www.asics.ws                                       ////\n////                                                             ////\n////  Downloaded from: http://www.opencores.org/projects/i2c/    ////\n////                                                             ////\n/////////////////////////////////////////////////////////////////////\n////                                                             ////\n//// Copyright (C) 2001 Richard Herveille                        ////\n////                    richard@asics.ws                         ////\n////                                                             ////\n//// This source file may be used and distributed without        ////\n//// restriction provided that this copyright statement is not   ////\n//// removed from the file and that any derivative work contains ////\n//// the original copyright notice and the associated disclaimer.////\n////                                                             ////\n////     THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY     ////\n//// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   ////\n//// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS   ////\n//// FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL THE AUTHOR      ////\n//// OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,         ////\n//// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES    ////\n//// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   ////\n//// GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        ////\n//// BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  ////\n//// LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT  ////\n//// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  ////\n//// OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE         ////\n//// POSSIBILITY OF SUCH DAMAGE.                                 ////\n////                                                             ////\n/////////////////////////////////////////////////////////////////////\n\n//  CVS Log\n//\n//  $Id: i2c_master_byte_ctrl.v,v 1.8 2009-01-19 20:29:26 rherveille Exp $\n//\n//  $Date: 2009-01-19 20:29:26 $\n//  $Revision: 1.8 $\n//  $Author: rherveille $\n//  $Locker:  $\n//  $State: Exp $\n//\n// Change History:\n//               $Log: not supported by cvs2svn $\n//               Revision 1.7  2004/02/18 11:40:46  rherveille\n//               Fixed a potential bug in the statemachine. During a 'stop' 2 cmd_ack signals were generated. Possibly canceling a new start command.\n//\n//               Revision 1.6  2003/08/09 07:01:33  rherveille\n//               Fixed a bug in the Arbitration Lost generation caused by delay on the (external) sda line.\n//               Fixed a potential bug in the byte controller's host-acknowledge generation.\n//\n//               Revision 1.5  2002/12/26 15:02:32  rherveille\n//               Core is now a Multimaster I2C controller\n//\n//               Revision 1.4  2002/11/30 22:24:40  rherveille\n//               Cleaned up code\n//\n//               Revision 1.3  2001/11/05 11:59:25  rherveille\n//               Fixed wb_ack_o generation bug.\n//               Fixed bug in the byte_controller statemachine.\n//               Added headers.\n//\n\n// synopsys translate_off\n`include \"timescale.v\"\n// synopsys translate_on\n\n`include \"i2c_master_defines.v\"\n\nmodule i2c_master_byte_ctrl (\n	clk, rst, nReset, ena, clk_cnt, start, stop, read, write, ack_in, din,\n	cmd_ack, ack_out, dout, i2c_busy, i2c_al, scl_i, scl_o, scl_oen, sda_i, sda_o, sda_oen );\n\n	//\n	// inputs & outputs\n	//\n	input clk;     // master clock\n	input rst;     // synchronous active high reset\n	input nReset;  // asynchronous active low reset\n	input ena;     // core enable signal\n\n	input [15:0] clk_cnt; // 4x SCL\n\n	// control inputs\n	input       start;\n	input       stop;\n	input       read;\n	input       write;\n	input       ack_in;\n	input [7:0] din;\n\n	// status outputs\n	output       cmd_ack;\n	reg cmd_ack;\n	output       ack_out;\n	reg ack_out;\n	output       i2c_busy;\n	output       i2c_al;\n	output [7:0] dout;\n\n	// I2C signals\n	input  scl_i;\n	output scl_o;\n	output scl_oen;\n	input  sda_i;\n	output sda_o;\n	output sda_oen;\n\n\n	//\n	// Variable declarations\n	//\n\n	// statemachine\n	parameter [4:0] ST_IDLE  = 5'b0_0000;\n	parameter [4:0] ST_START = 5'b0_0001;\n	parameter [4:0] ST_READ  = 5'b0_0010;\n	parameter [4:0] ST_WRITE = 5'b0_0100;\n	parameter [4:0] ST_ACK   = 5'b0_1000;\n	parameter [4:0] ST_STOP  = 5'b1_0000;\n\n	// signals for bit_controller\n	reg  [3:0] core_cmd;\n	reg        core_txd;\n	wire       core_ack, core_rxd;\n\n	// signals for shift register\n	reg [7:0] sr; //8bit shift register\n	reg       shift, ld;\n\n	// signals for state machine\n	wire       go;\n	reg  [2:0] dcnt;\n	wire       cnt_done;\n\n	//\n	// Module body\n	//\n\n	// hookup bit_controller\n	i2c_master_bit_ctrl bit_controller (\n		.clk     ( clk      ),\n		.rst     ( rst      ),\n		.nReset  ( nReset   ),\n		.ena     ( ena      ),\n		.clk_cnt ( clk_cnt  ),\n		.cmd     ( core_cmd ),\n		.cmd_ack ( core_ack ),\n		.busy    ( i2c_busy ),\n		.al      ( i2c_al   ),\n		.din     ( core_txd ),\n		.dout    ( core_rxd ),\n		.scl_i   ( scl_i    ),\n		.scl_o   ( scl_o    ),\n		.scl_oen ( scl_oen  ),\n		.sda_i   ( sda_i    ),\n		.sda_o   ( sda_o    ),\n		.sda_oen ( sda_oen  )\n	);\n\n	// generate go-signal\n	assign go = (read | write | stop) & ~cmd_ack;\n\n	// assign dout output to shift-register\n	assign dout = sr;\n\n	// generate shift register\n	always @(posedge clk or negedge nReset)\n	  if (!nReset)\n	    sr <= #1 8'h0;\n	  else if (rst)\n	    sr <= #1 8'h0;\n	  else if (ld)\n	    sr <= #1 din;\n	  else if (shift)\n	    sr <= #1 {sr[6:0], core_rxd};\n\n	// generate counter\n	always @(posedge clk or negedge nReset)\n	  if (!nReset)\n	    dcnt <= #1 3'h0;\n	  else if (rst)\n	    dcnt <= #1 3'h0;\n	  else if (ld)\n	    dcnt <= #1 3'h7;\n	  else if (shift)\n	    dcnt <= #1 dcnt - 3'h1;\n\n	assign cnt_done = ~(|dcnt);\n\n	//\n	// state machine\n	//\n	reg [4:0] c_state; // synopsys enum_state\n\n	always @(posedge clk or negedge nReset)\n	  if (!nReset)\n	    begin\n	        core_cmd <= #1 `I2C_CMD_NOP;\n	        core_txd <= #1 1'b0;\n	        shift    <= #1 1'b0;\n	        ld       <= #1 1'b0;\n	        cmd_ack  <= #1 1'b0;\n	        c_state  <= #1 ST_IDLE;\n	        ack_out  <= #1 1'b0;\n	    end\n	  else if (rst | i2c_al)\n	   begin\n	       core_cmd <= #1 `I2C_CMD_NOP;\n	       core_txd <= #1 1'b0;\n	       shift    <= #1 1'b0;\n	       ld       <= #1 1'b0;\n	       cmd_ack  <= #1 1'b0;\n	       c_state  <= #1 ST_IDLE;\n	       ack_out  <= #1 1'b0;\n	   end\n	else\n	  begin\n	      // initially reset all signals\n	      core_txd <= #1 sr[7];\n	      shift    <= #1 1'b0;\n	      ld       <= #1 1'b0;\n	      cmd_ack  <= #1 1'b0;\n\n	      case (c_state) // synopsys full_case parallel_case\n	        ST_IDLE:\n	          if (go)\n	            begin\n	                if (start)\n	                  begin\n	                      c_state  <= #1 ST_START;\n	                      core_cmd <= #1 `I2C_CMD_START;\n	                  end\n	                else if (read)\n	                  begin\n	                      c_state  <= #1 ST_READ;\n	                      core_cmd <= #1 `I2C_CMD_READ;\n	                  end\n	                else if (write)\n	                  begin\n	                      c_state  <= #1 ST_WRITE;\n	                      core_cmd <= #1 `I2C_CMD_WRITE;\n	                  end\n	                else // stop\n	                  begin\n	                      c_state  <= #1 ST_STOP;\n	                      core_cmd <= #1 `I2C_CMD_STOP;\n	                  end\n\n	                ld <= #1 1'b1;\n	            end\n\n	        ST_START:\n	          if (core_ack)\n	            begin\n	                if (read)\n	                  begin\n	                      c_state  <= #1 ST_READ;\n	                      core_cmd <= #1 `I2C_CMD_READ;\n	                  end\n	                else\n	                  begin\n	                      c_state  <= #1 ST_WRITE;\n	                      core_cmd <= #1 `I2C_CMD_WRITE;\n	                  end\n\n	                ld <= #1 1'b1;\n	            end\n\n	        ST_WRITE:\n	          if (core_ack)\n	            if (cnt_done)\n	              begin\n	                  c_state  <= #1 ST_ACK;\n	                  core_cmd <= #1 `I2C_CMD_READ;\n	              end\n	            else\n	              begin\n	                  c_state  <= #1 ST_WRITE;       // stay in same state\n	                  core_cmd <= #1 `I2C_CMD_WRITE; // write next bit\n	                  shift    <= #1 1'b1;\n	              end\n\n	        ST_READ:\n	          if (core_ack)\n	            begin\n	                if (cnt_done)\n	                  begin\n	                      c_state  <= #1 ST_ACK;\n	                      core_cmd <= #1 `I2C_CMD_WRITE;\n	                  end\n	                else\n	                  begin\n	                      c_state  <= #1 ST_READ;       // stay in same state\n	                      core_cmd <= #1 `I2C_CMD_READ; // read next bit\n	                  end\n\n	                shift    <= #1 1'b1;\n	                core_txd <= #1 ack_in;\n	            end\n\n	        ST_ACK:\n	          if (core_ack)\n	            begin\n	               if (stop)\n	                 begin\n	                     c_state  <= #1 ST_STOP;\n	                     core_cmd <= #1 `I2C_CMD_STOP;\n	                 end\n	               else\n	                 begin\n	                     c_state  <= #1 ST_IDLE;\n	                     core_cmd <= #1 `I2C_CMD_NOP;\n\n	                     // generate command acknowledge signal\n	                     cmd_ack  <= #1 1'b1;\n	                 end\n\n	                 // assign ack_out output to bit_controller_rxd (contains last received bit)\n	                 ack_out <= #1 core_rxd;\n\n	                 core_txd <= #1 1'b1;\n	             end\n	           else\n	             core_txd <= #1 ack_in;\n\n	        ST_STOP:\n	          if (core_ack)\n	            begin\n	                c_state  <= #1 ST_IDLE;\n	                core_cmd <= #1 `I2C_CMD_NOP;\n\n	                // generate command acknowledge signal\n	                cmd_ack  <= #1 1'b1;\n	            end\n\n	      endcase\n	  end\nendmodule\n","lang":"verilog"};
processSrcData(g_data);